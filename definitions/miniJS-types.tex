\documentclass[nocopyrightspace,onecolumn]{sigplanconf}
\input{../../lectures/header}

\begin{document}

\title{Explicitly Typed \miniJS}
\authorinfo{}{}{}
\date{}
\maketitle

\section{Syntax}

\vsp

\begin{mdframed}
  \begin{gather*}
    \gt \in \mtt{Type} ::= \numT \x \boolT \x \strT \x \unitT \x
    \arrT{\vec{\gt}_i}{\gt_r} \x \listT{\gt}    
  \end{gather*}
  \nvsp
\end{mdframed}

\vsp

\begin{mdframed}
  \begin{gather*}
    n \in \Int \qquad b \in \Bool \qquad \str \in \String \qquad x
    \in \Variable
  \end{gather*}
  \begin{align*}
    t \in \Term &::= c \x e
    \\
    c \in \Cmd &::= \vec{t}_i \x x := e \x \while \x \out
    \\
    e \in \Exp &::= n \x b \x \str \x \unit \x x \x \uop e
    \x e_1 \bop e_2\\
    &\lx \cond \x \inpt \x e_f(\vec{e}_i)\\
    &\lx \letr[\set{x_i\!:\!\gt_i = e_i}] \x \funT\\
    &\lx []_\gt \x [\vec{e}_i] \x e.\kw{head} \x e.\kw{tail}
    \\
    \uop \in \UnOp &::= - \x \neg
    \\
    \bop \in \BinOp &::= + \x - \x \times \x \div \x \land \x
    \lor \x = \x \neq \x \leq \x < \x ::
  \end{align*}
\end{mdframed}

\section{Domains}

\begin{align*}
  \gr \in \mtt{TypeEnv} &= \Variable \to \mtt{Type}
  \\
  :\ \in \mtt{TypeEval} &= \mtt{TypeEnv} \times \Term \to \mtt{Type}
\end{align*}

\vsp

\noindent We abuse notation in the following rules so that $\vec{x_i}$
means a vector of $x_i$'s of length $n$ with $1 \leq i \leq n$, and the
phrase $x_i : y_i$ means $\forall x_i \in \vec{x_i} \ .\ \exists y_i\
.\ x_i : y_i$.

\section{Rules}

\infrule
{ \env t_i : \gt_i }
{ \env \vec{t_i} : \vec{\gt}_i.\mtxt{last} }

\infrule
{ \gr(x) = \gt \andalso \env e : \gt }
{ \env x := e : \unitT } 

\infrule
{ \env e : \gt_1 \andalso \env t : \gt_2 }
{ \env \while : \unitT }

\infrule
{ \env e : \gt }
{ \env \out : \unitT }

\infax
{ \env n : \numT }

\infax
{ \env b : \boolT }

\infax
{ \env s : \strT }

\infax
{ \env \unit : \unitT }

\infrule
{ \gr(x) = \gt }
{ \env x : \gt }

\infrule
{ \env e : \numT }
{ \env -e : \numT }

\infrule
{ \env e : \gt }
{ \env \neg e : \boolT }

\infrule
{ \env e_1 : \gt \andalso \env e_2 : \gt \andalso \gt \in \{\numT, \strT\} }
{ \env e_1 + e_2 : \gt }

\infrule
{ \bop \in \{-, \times, \div\} \andalso \env e_1 : \numT \andalso \env
  e_2 : \numT }
{ \env e_1 \bop e_2 : \numT }

\infrule
{ \bop \in \{\land, \lor, =, \neq\} \andalso \env e_1 : \gt_1 \andalso
  \env e_2 : \gt_2 }
{ \env e_1 \bop e_2 : \boolT }

\infrule
{ \bop \in \{\leq, <\} \andalso \env e_1 : \gt \andalso \env e_2 : \gt
  \andalso \gt \in \{\numT, \strT\} }
{ \env e_1 \bop e_2 : \boolT }

\infrule
{ \env e_1 : \gt \andalso \env e_2 : \listT{\gt} }
{ \env e_1 :: e_2 : \listT{\gt} }

\infrule
{ \env e : \gt_1 \andalso \env t_1 : \gt_2 \andalso \env t_2 : \gt_2 }
{ \env \cond : \gt_2 }

\infax
{ \env \inpt : \typ }

\infrule
{ \gr' = \gr[x_i \mapsto \gt_i] \andalso \env['] e_i : \gt_i \andalso
  \env['] t : \gt }
{ \env \letr[\set{x_i\!:\!\gt_i = e_i}] : \gt }

\infrule
{ \gr' = \gr[x_i \mapsto \gt_i] \andalso \env['] t : \gt_r }
{ \env \funT : \arrT{\vec{\gt_i}}{\gt_r} }

\infrule
{ \env e_f : \arrT{\vec{\gt}_i}{\gt_r} \andalso \env e_i : \gt_i }
{ \env e_f(\vec{e}_i) : \gt_r }

\infax
{ \env \listT{{}}_\gt : \listT{\gt} }

\infrule
{ \env e_i : \gt }
{ \env \listT{\vec{e_i}} : \listT{\gt} }

\infrule
{ \env e : \listT{\gt} }
{ \env e.\kw{head} : \gt }

\infrule
{ \env e : \listT{\gt} }
{ \env e.\kw{tail} : \listT{\gt} }

\end{document}